/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type CommonEncryptionCbcsObservation struct {
}

type CommonEncryptionCbcsParameters struct {

	// +kubebuilder:validation:Optional
	DefaultContentKey []DefaultContentKeyParameters `json:"defaultContentKey,omitempty" tf:"default_content_key,omitempty"`

	// A drm_fairplay block as defined below. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	DrmFairplay []DrmFairplayParameters `json:"drmFairplay,omitempty" tf:"drm_fairplay,omitempty"`

	// +kubebuilder:validation:Optional
	EnabledProtocols []EnabledProtocolsParameters `json:"enabledProtocols,omitempty" tf:"enabled_protocols,omitempty"`
}

type CommonEncryptionCencDefaultContentKeyObservation struct {
}

type CommonEncryptionCencDefaultContentKeyParameters struct {

	// Label can be used to specify Content Key when creating a Streaming Locator. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Policy used by Default Key. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	PolicyName *string `json:"policyName,omitempty" tf:"policy_name,omitempty"`
}

type CommonEncryptionCencEnabledProtocolsObservation struct {
}

type CommonEncryptionCencEnabledProtocolsParameters struct {

	// +kubebuilder:validation:Optional
	Dash *bool `json:"dash,omitempty" tf:"dash,omitempty"`

	// +kubebuilder:validation:Optional
	Download *bool `json:"download,omitempty" tf:"download,omitempty"`

	// +kubebuilder:validation:Optional
	Hls *bool `json:"hls,omitempty" tf:"hls,omitempty"`

	// +kubebuilder:validation:Optional
	SmoothStreaming *bool `json:"smoothStreaming,omitempty" tf:"smooth_streaming,omitempty"`
}

type CommonEncryptionCencObservation struct {
}

type CommonEncryptionCencParameters struct {

	// +kubebuilder:validation:Optional
	DefaultContentKey []CommonEncryptionCencDefaultContentKeyParameters `json:"defaultContentKey,omitempty" tf:"default_content_key,omitempty"`

	// A drm_playready block as defined below. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	DrmPlayready []DrmPlayreadyParameters `json:"drmPlayready,omitempty" tf:"drm_playready,omitempty"`

	// Template for the URL of the custom service delivering licenses to end user players. Not required when using Azure Media Services for issuing licenses. The template supports replaceable tokens that the service will update at runtime with the value specific to the request. The currently supported token values are {AlternativeMediaId}, which is replaced with the value of StreamingLocatorId.AlternativeMediaId, and {ContentKeyId}, which is replaced with the value of identifier of the key being requested. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	DrmWidevineCustomLicenseAcquisitionURLTemplate *string `json:"drmWidevineCustomLicenseAcquisitionUrlTemplate,omitempty" tf:"drm_widevine_custom_license_acquisition_url_template,omitempty"`

	// +kubebuilder:validation:Optional
	EnabledProtocols []CommonEncryptionCencEnabledProtocolsParameters `json:"enabledProtocols,omitempty" tf:"enabled_protocols,omitempty"`
}

type DefaultContentKeyObservation struct {
}

type DefaultContentKeyParameters struct {

	// Label can be used to specify Content Key when creating a Streaming Locator. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	Label *string `json:"label,omitempty" tf:"label,omitempty"`

	// Policy used by Default Key. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	PolicyName *string `json:"policyName,omitempty" tf:"policy_name,omitempty"`
}

type DrmFairplayObservation struct {
}

type DrmFairplayParameters struct {

	// All license to be persistent or not. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	AllowPersistentLicense *bool `json:"allowPersistentLicense,omitempty" tf:"allow_persistent_license,omitempty"`

	// +kubebuilder:validation:Optional
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty" tf:"custom_license_acquisition_url_template,omitempty"`
}

type DrmPlayreadyObservation struct {
}

type DrmPlayreadyParameters struct {

	// Custom attributes for PlayReady. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	CustomAttributes *string `json:"customAttributes,omitempty" tf:"custom_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	CustomLicenseAcquisitionURLTemplate *string `json:"customLicenseAcquisitionUrlTemplate,omitempty" tf:"custom_license_acquisition_url_template,omitempty"`
}

type EnabledProtocolsObservation struct {
}

type EnabledProtocolsParameters struct {

	// +kubebuilder:validation:Optional
	Dash *bool `json:"dash,omitempty" tf:"dash,omitempty"`

	// +kubebuilder:validation:Optional
	Download *bool `json:"download,omitempty" tf:"download,omitempty"`

	// +kubebuilder:validation:Optional
	Hls *bool `json:"hls,omitempty" tf:"hls,omitempty"`

	// +kubebuilder:validation:Optional
	SmoothStreaming *bool `json:"smoothStreaming,omitempty" tf:"smooth_streaming,omitempty"`
}

type NoEncryptionEnabledProtocolsObservation struct {
}

type NoEncryptionEnabledProtocolsParameters struct {

	// +kubebuilder:validation:Optional
	Dash *bool `json:"dash,omitempty" tf:"dash,omitempty"`

	// +kubebuilder:validation:Optional
	Download *bool `json:"download,omitempty" tf:"download,omitempty"`

	// +kubebuilder:validation:Optional
	Hls *bool `json:"hls,omitempty" tf:"hls,omitempty"`

	// +kubebuilder:validation:Optional
	SmoothStreaming *bool `json:"smoothStreaming,omitempty" tf:"smooth_streaming,omitempty"`
}

type StreamingPolicyObservation struct {

	// The ID of the Streaming Policy.
	ID *string `json:"id,omitempty" tf:"id,omitempty"`
}

type StreamingPolicyParameters struct {

	// A common_encryption_cbcs block as defined below. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	CommonEncryptionCbcs []CommonEncryptionCbcsParameters `json:"commonEncryptionCbcs,omitempty" tf:"common_encryption_cbcs,omitempty"`

	// A common_encryption_cenc block as defined below. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	CommonEncryptionCenc []CommonEncryptionCencParameters `json:"commonEncryptionCenc,omitempty" tf:"common_encryption_cenc,omitempty"`

	// Default Content Key used by current Streaming Policy. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	DefaultContentKeyPolicyName *string `json:"defaultContentKeyPolicyName,omitempty" tf:"default_content_key_policy_name,omitempty"`

	// The Media Services account name. Changing this forces a new Streaming Policy to be created.
	// +crossplane:generate:reference:type=ServicesAccount
	// +kubebuilder:validation:Optional
	MediaServicesAccountName *string `json:"mediaServicesAccountName,omitempty" tf:"media_services_account_name,omitempty"`

	// Reference to a ServicesAccount to populate mediaServicesAccountName.
	// +kubebuilder:validation:Optional
	MediaServicesAccountNameRef *v1.Reference `json:"mediaServicesAccountNameRef,omitempty" tf:"-"`

	// Selector for a ServicesAccount to populate mediaServicesAccountName.
	// +kubebuilder:validation:Optional
	MediaServicesAccountNameSelector *v1.Selector `json:"mediaServicesAccountNameSelector,omitempty" tf:"-"`

	// A no_encryption_enabled_protocols block as defined below. Changing this forces a new Streaming Policy to be created.
	// +kubebuilder:validation:Optional
	NoEncryptionEnabledProtocols []NoEncryptionEnabledProtocolsParameters `json:"noEncryptionEnabledProtocols,omitempty" tf:"no_encryption_enabled_protocols,omitempty"`

	// The name of the Resource Group where the Streaming Policy should exist. Changing this forces a new Streaming Policy to be created.
	// +crossplane:generate:reference:type=github.com/upbound/official-providers/provider-azure/apis/azure/v1beta1.ResourceGroup
	// +kubebuilder:validation:Optional
	ResourceGroupName *string `json:"resourceGroupName,omitempty" tf:"resource_group_name,omitempty"`

	// Reference to a ResourceGroup in azure to populate resourceGroupName.
	// +kubebuilder:validation:Optional
	ResourceGroupNameRef *v1.Reference `json:"resourceGroupNameRef,omitempty" tf:"-"`

	// Selector for a ResourceGroup in azure to populate resourceGroupName.
	// +kubebuilder:validation:Optional
	ResourceGroupNameSelector *v1.Selector `json:"resourceGroupNameSelector,omitempty" tf:"-"`
}

// StreamingPolicySpec defines the desired state of StreamingPolicy
type StreamingPolicySpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     StreamingPolicyParameters `json:"forProvider"`
}

// StreamingPolicyStatus defines the observed state of StreamingPolicy.
type StreamingPolicyStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        StreamingPolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// StreamingPolicy is the Schema for the StreamingPolicys API. Manages a Streaming Policy.
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type StreamingPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              StreamingPolicySpec   `json:"spec"`
	Status            StreamingPolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// StreamingPolicyList contains a list of StreamingPolicys
type StreamingPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []StreamingPolicy `json:"items"`
}

// Repository type metadata.
var (
	StreamingPolicy_Kind             = "StreamingPolicy"
	StreamingPolicy_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: StreamingPolicy_Kind}.String()
	StreamingPolicy_KindAPIVersion   = StreamingPolicy_Kind + "." + CRDGroupVersion.String()
	StreamingPolicy_GroupVersionKind = CRDGroupVersion.WithKind(StreamingPolicy_Kind)
)

func init() {
	SchemeBuilder.Register(&StreamingPolicy{}, &StreamingPolicyList{})
}
